[
  {
    "id": 1,
    "name": "Quick Sort",
    "category": "Sorting",
    "description": "An efficient divide-and-conquer sorting algorithm that picks a pivot element and partitions the array into two subarrays.",
    "link": "/algorithms/quick-sort",
    "best_case_time_complexity": "O(n log n)",
    "average_case_time_complexity": "O(n log n)",
    "worst_case_time_complexity": "O(n²)",
    "space_complexity": "O(log n)",
    "visualization": false
  },
  {
    "id": 2,
    "name": "Merge Sort",
    "category": "Sorting",
    "description": "A stable, divide-and-conquer sorting algorithm that divides the input array into two halves, sorts each half recursively, and then merges the sorted halves back together.",
    "link": "/algorithms/merge-sort",
    "best_case_time_complexity": "O(n log n)",
    "average_case_time_complexity": "O(n log n)",
    "worst_case_time_complexity": "O(n log n)",
    "space_complexity": "O(n)",
    "visualization": false
  },
  {
    "id": 3,
    "name": "Bubble Sort",
    "category": "Sorting",
    "description": "A simple comparison-based sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order.",
    "link": "/algorithms/bubble-sort",
    "best_case_time_complexity": "O(n)",
    "average_case_time_complexity": "O(n²)",
    "worst_case_time_complexity": "O(n²)",
    "space_complexity": "O(1)",
    "visualization": false
  },
  {
    "id": 4,
    "name": "Selection Sort",
    "category": "Sorting",
    "description": "A simple, in-place comparison-based sorting algorithm that divides the input list into two parts: a sorted and an unsorted section.",
    "link": "/algorithms/selection-sort",
    "best_case_time_complexity": "O(n²)",
    "average_case_time_complexity": "O(n²)",
    "worst_case_time_complexity": "O(n²)",
    "space_complexity": "O(1)",
    "visualization": false
  },
  {
    "id": 5,
    "name": "Heap Sort",
    "category": "Sorting",
    "description": "A comparison-based sorting algorithm that utilizes a binary heap data structure.",
    "link": "/algorithms/heap-sort",
    "best_case_time_complexity": "O(n log n)",
    "average_case_time_complexity": "O(n log n)",
    "worst_case_time_complexity": "O(n log n)",
    "space_complexity": "O(1)",
    "visualization": false
  },
  {
    "id": 6,
    "name": "Insertion Sort",
    "category": "Sorting",
    "description": "A simple and efficient in-place sorting algorithm that builds a sorted array one element at a time.",
    "link": "/algorithms/insertion-sort",
    "best_case_time_complexity": "O(n)",
    "average_case_time_complexity": "O(n²)",
    "worst_case_time_complexity": "O(n²)",
    "space_complexity": "O(1)",
    "visualization": false
  },
  {
    "id": 7,
    "name": "Radix Sort",
    "category": "Sorting",
    "description": "A non-comparative integer sorting algorithm that sorts numbers by processing individual digits.",
    "link": "/algorithms/radix-sort",
    "best_case_time_complexity": "O(nk)",
    "average_case_time_complexity": "O(nk)",
    "worst_case_time_complexity": "O(nk)",
    "space_complexity": "O(n + k)",
    "visualization": false
  },
  {
    "id": 8,
    "name": "Counting Sort",
    "category": "Sorting",
    "description": "An efficient non-comparison sorting algorithm that counts occurrences of each unique element.",
    "link": "/algorithms/counting-sort",
    "best_case_time_complexity": "O(n + k)",
    "average_case_time_complexity": "O(n + k)",
    "worst_case_time_complexity": "O(n + k)",
    "space_complexity": "O(k)",
    "visualization": false
  },
  {
    "id": 9,
    "name": "Shell Sort",
    "category": "Sorting",
    "description": "An optimization of insertion sort that allows the exchange of items that are far apart.",
    "link": "/algorithms/shell-sort",
    "best_case_time_complexity": "O(n log n)",
    "average_case_time_complexity": "O(n log n)",
    "worst_case_time_complexity": "O(n²)",
    "space_complexity": "O(1)",
    "visualization": false
  },
  {
    "id": 10,
    "name": "Binary Search",
    "category": "Searching",
    "description": "An efficient algorithm for finding an item from a sorted list of items by dividing the search interval in half.",
    "link": "/algorithms/binary-search",
    "best_case_time_complexity": "O(1)",
    "average_case_time_complexity": "O(log n)",
    "worst_case_time_complexity": "O(log n)",
    "space_complexity": "O(1)",
    "visualization": false
  },
  {
    "id": 11,
    "name": "Linear Search",
    "category": "Searching",
    "description": "A straightforward searching algorithm that checks each element in the list sequentially until the desired element is found.",
    "link": "/algorithms/linear-search",
    "best_case_time_complexity": "O(1)",
    "average_case_time_complexity": "O(n)",
    "worst_case_time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "visualization": false
  },
  {
    "id": 12,
    "name": "Depth-First Search (DFS)",
    "category": "Searching",
    "description": "An algorithm for traversing or searching tree or graph data structures, exploring as far as possible along each branch before backtracking.",
    "link": "/algorithms/depth-first-search",
    "best_case_time_complexity": "O(V + E)",
    "average_case_time_complexity": "O(V + E)",
    "worst_case_time_complexity": "O(V + E)",
    "space_complexity": "O(V)",
    "visualization": false
  },
  {
    "id": 13,
    "name": "Breadth-First Search (BFS)",
    "category": "Searching",
    "description": "A graph traversal algorithm that explores all neighbor nodes at the present depth before moving on to the next depth level.",
    "link": "/algorithms/breadth-first-search",
    "best_case_time_complexity": "O(V + E)",
    "average_case_time_complexity": "O(V + E)",
    "worst_case_time_complexity": "O(V + E)",
    "space_complexity": "O(V)",
    "visualization": false
  },
  {
    "id": 14,
    "name": "Jump Search",
    "category": "Searching",
    "description": "An algorithm for sorted arrays that combines linear search and binary search principles by dividing the array into blocks.",
    "link": "/algorithms/jump-search",
    "best_case_time_complexity": "O(1)",
    "average_case_time_complexity": "O(√n)",
    "worst_case_time_complexity": "O(√n)",
    "space_complexity": "O(1)",
    "visualization": false
  },
  {
    "id": 15,
    "name": "Interpolation Search",
    "category": "Searching",
    "description": "An improved variant of binary search that estimates the position of the target value based on the endpoints of the array.",
    "link": "/algorithms/interpolation-search",
    "best_case_time_complexity": "O(1)",
    "average_case_time_complexity": "O(log log n)",
    "worst_case_time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "visualization": false
  },
  {
    "id": 16,
    "name": "Exponential Search",
    "category": "Searching",
    "description": "An algorithm for searching in a sorted array that finds a range for the target value before performing binary search.",
    "link": "/algorithms/exponential-search",
    "best_case_time_complexity": "O(1)",
    "average_case_time_complexity": "O(log n)",
    "worst_case_time_complexity": "O(log n)",
    "space_complexity": "O(1)",
    "visualization": false
  },
  {
    "id": 17,
    "name": "Fibonacci Search",
    "category": "Searching",
    "description": "A searching algorithm that uses Fibonacci numbers to calculate the size of the subarrays to be searched, combining binary search principles.",
    "link": "/algorithms/fibonacci-search",
    "best_case_time_complexity": "O(1)",
    "average_case_time_complexity": "O(log n)",
    "worst_case_time_complexity": "O(log n)",
    "space_complexity": "O(1)",
    "visualization": false
  },
  {
    "id": 18,
    "name": "Ternary Search",
    "category": "Searching",
    "description": "An algorithm that divides the array into three parts and recursively searches for the target value, providing a balanced search.",
    "link": "/algorithms/ternary-search",
    "best_case_time_complexity": "O(1)",
    "average_case_time_complexity": "O(log n)",
    "worst_case_time_complexity": "O(log n)",
    "space_complexity": "O(1)",
    "visualization": false
  },
  {
    "id": 19,
    "name": "Fibonacci Sequence (DP)",
    "category": "Dynamic Programming",
    "description": "A dynamic programming algorithm to compute the Fibonacci sequence efficiently, storing previous values to avoid redundancy.",
    "link": "/algorithms/fibonacci-dp",
    "best_case_time_complexity": "O(1)",
    "average_case_time_complexity": "O(n)",
    "worst_case_time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "visualization": false
  },
  {
    "id": 20,
    "name": "Knapsack Problem",
    "category": "Dynamic Programming",
    "description": "A combinatorial optimization problem that determines the maximum value obtainable from items with given weights and values.",
    "link": "/algorithms/knapsack",
    "best_case_time_complexity": "O(1)",
    "average_case_time_complexity": "O(nW)",
    "worst_case_time_complexity": "O(nW)",
    "space_complexity": "O(nW)",
    "visualization": false
  },
  {
    "id": 21,
    "name": "Longest Common Subsequence (LCS)",
    "category": "Dynamic Programming",
    "description": "An algorithm used to find the longest subsequence present in two sequences using dynamic programming.",
    "link": "/algorithms/longest-common-subsequence",
    "best_case_time_complexity": "O(1)",
    "average_case_time_complexity": "O(mn)",
    "worst_case_time_complexity": "O(mn)",
    "space_complexity": "O(mn)",
    "visualization": false
  },
  {
    "id": 22,
    "name": "Longest Increasing Subsequence (LIS)",
    "category": "Dynamic Programming",
    "description": "An algorithm to find the longest subsequence of a sequence with elements sorted in increasing order.",
    "link": "/algorithms/longest-increasing-subsequence",
    "best_case_time_complexity": "O(n)",
    "average_case_time_complexity": "O(n²)",
    "worst_case_time_complexity": "O(n²)",
    "space_complexity": "O(n)",
    "visualization": false
  },
  {
    "id": 23,
    "name": "Edit Distance",
    "category": "Dynamic Programming",
    "description": "A dynamic programming algorithm that computes the minimum number of operations required to transform one string into another.",
    "link": "/algorithms/edit-distance",
    "best_case_time_complexity": "O(1)",
    "average_case_time_complexity": "O(mn)",
    "worst_case_time_complexity": "O(mn)",
    "space_complexity": "O(mn)",
    "visualization": false
  },
  {
    "id": 24,
    "name": "Matrix Chain Multiplication",
    "category": "Dynamic Programming",
    "description": "An algorithm to find the most efficient way to multiply a given sequence of matrices using dynamic programming.",
    "link": "/algorithms/matrix-chain-multiplication",
    "best_case_time_complexity": "O(n)",
    "average_case_time_complexity": "O(n³)",
    "worst_case_time_complexity": "O(n³)",
    "space_complexity": "O(n²)",
    "visualization": false
  },
  {
    "id": 25,
    "name": "Coin Change Problem",
    "category": "Dynamic Programming",
    "description": "An algorithm that determines the minimum number of coins required to make a given amount using specified coin denominations.",
    "link": "/algorithms/coin-change",
    "best_case_time_complexity": "O(1)",
    "average_case_time_complexity": "O(nm)",
    "worst_case_time_complexity": "O(nm)",
    "space_complexity": "O(n)",
    "visualization": false
  },
  {
    "id": 26,
    "name": "Subset Sum Problem",
    "category": "Dynamic Programming",
    "description": "A problem that determines whether there is a subset of a given set that sums up to a specific target using dynamic programming.",
    "link": "/algorithms/subset-sum",
    "best_case_time_complexity": "O(1)",
    "average_case_time_complexity": "O(nW)",
    "worst_case_time_complexity": "O(nW)",
    "space_complexity": "O(W)",
    "visualization": false
  },
  {
    "id": 27,
    "name": "Dijkstra's Algorithm",
    "category": "Graph Algorithms",
    "description": "An algorithm for finding the shortest paths between nodes in a weighted graph using a priority queue.",
    "link": "/algorithms/dijkstras-algorithm",
    "best_case_time_complexity": "O(E + V log V)",
    "average_case_time_complexity": "O(E log V)",
    "worst_case_time_complexity": "O(V²)",
    "space_complexity": "O(V)",
    "visualization": false
  },
  {
    "id": 28,
    "name": "Bellman-Ford Algorithm",
    "category": "Graph Algorithms",
    "description": "An algorithm for finding shortest paths from a single source vertex in a graph with negative weight edges.",
    "link": "/algorithms/bellman-ford",
    "best_case_time_complexity": "O(V)",
    "average_case_time_complexity": "O(VE)",
    "worst_case_time_complexity": "O(VE)",
    "space_complexity": "O(V)",
    "visualization": false
  },
  {
    "id": 29,
    "name": "Floyd-Warshall Algorithm",
    "category": "Graph Algorithms",
    "description": "A dynamic programming algorithm used to find shortest paths between all pairs of vertices in a weighted graph.",
    "link": "/algorithms/floyd-warshall",
    "best_case_time_complexity": "O(V³)",
    "average_case_time_complexity": "O(V³)",
    "worst_case_time_complexity": "O(V³)",
    "space_complexity": "O(V²)",
    "visualization": false
  },
  {
    "id": 30,
    "name": "Prim's Algorithm",
    "category": "Graph Algorithms",
    "description": "A greedy algorithm for finding the minimum spanning tree of a weighted undirected graph.",
    "link": "/algorithms/prims-algorithm",
    "best_case_time_complexity": "O(E)",
    "average_case_time_complexity": "O(E log V)",
    "worst_case_time_complexity": "O(E log V)",
    "space_complexity": "O(V)",
    "visualization": false
  },
  {
    "id": 31,
    "name": "Kruskal's Algorithm",
    "category": "Graph Algorithms",
    "description": "A greedy algorithm that finds the minimum spanning tree for a connected weighted graph by adding edges without forming cycles.",
    "link": "/algorithms/kruskals-algorithm",
    "best_case_time_complexity": "O(E log E)",
    "average_case_time_complexity": "O(E log E)",
    "worst_case_time_complexity": "O(E log E)",
    "space_complexity": "O(V)",
    "visualization": false
  },
  {
    "id": 32,
    "name": "Topological Sorting",
    "category": "Graph Algorithms",
    "description": "An algorithm for ordering vertices of a directed acyclic graph (DAG) in a linear sequence based on dependencies.",
    "link": "/algorithms/topological-sorting",
    "best_case_time_complexity": "O(V + E)",
    "average_case_time_complexity": "O(V + E)",
    "worst_case_time_complexity": "O(V + E)",
    "space_complexity": "O(V)",
    "visualization": false
  }
]
